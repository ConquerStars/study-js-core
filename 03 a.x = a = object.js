"use strict"; // 下面的验证demo需要使用严格模式

var a = {n: 1}
a.x = a = {n: 2}
console.log(a.x); // undefined

// 从前面的课程学习笔记中了解到-“var 声明”语句中的等号左边，绝不可能是一个表达式，只能是一个标识符
// 而 a.x = a = {n: 2} 是一个连续的赋值运算
// 《JavaScript 权威指南》 4.7.7 运算顺序  JavaScript 总是严格按照从左至右的顺序来计算表达式。
// 所以实际上 a.x 这个左操作数的计算结果是一个引用 暂存了a这个变量
// 等号后面 a(引用) = {n: 2}(值) 表达式中，a 被重新赋值为 {n: 2}的字面量值（a 引用指向了{n: 2}）
// 而最左边的a.x中暂存的a引用 有且仅有运行环境知道了 最后的操作是向a.x这个引用赋值了 a = {n: 2}这个表达式返回的结果 {n: 2}
// 但是这个有且仅有运行环境知道的旧值 a 的引用也被销毁了
// 所以当我们重新去获取a.x的值的时候 实际上是获取的新引用a的属性x  自然是不存在的 undefined

// 验证
// 声明“原始的变量a”
var a = {n:1};
// 使它的属性表冻结（不能再添加属性）
Object.freeze(a);
try {
  // 本节的示例代码
  a.x = a = {n:2};
}
catch (x) {
  // 异常发生，说明第二次赋值“a.x = ...”中操作的`a`正是原始的变量a
  console.log('第二次赋值导致异常.');
}

// 第一次赋值是成功的
console.log(a.n); // 2