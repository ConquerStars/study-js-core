// 解释 var x = y = 100 时先了解下面的一些概念

/**
 * 除标签声明之外，JavaScript 中一共只有六条声明用的语句
 * 注意，所有真正被定义“声明”的语法结构都一定是“语句”，并且都用于声明一个或 *多个* 标识符。这里的标识符包括变量、常量等。
 * var  let  const  function  class（该类的作用域内部是处理严格模式的）  import导入标识符并作为常量（可以有多种声明标识符的模式和方法）
 * 除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）
 * for ...      try...catch...
 * 结论:    1·都意味着 JavaScript 将可以通过“静态”语法分析发现那些声明的标识符
 *          2.标识符对应的变量 / 常量 “一定” 会在用户代码执行前就 *已经* 被创建在作用域中
 */

/**
 * 声明是在 *语法分析* 阶段就处理的，并且因此它会使得当前代码上下文在正式执行之前就拥有了被声明的标识符，例如x。
 * JavaScript 虽然被称为是“动态语言”，但确实是拥有静态语义的。
 * 在早期，这个静态语义其实并没有处理得太好，一个典型的问题就是所谓的“变量提升”。也就是，可以在变量声明之前访问该变量。
 */

console.log('变量提升', x); // undefined
var x = 100;
console.log(x); // 100

/**
 * 由于标识符是在用户代码 *执行之前* 就已经由静态分析得到，并且创建在环境中，因此 let 声明的变量和 var 声明的变量在这一点上 *没有不同* ：它们都是在读取一个“已经存在的”标识符名
 */
var y = "outer";
function f() {
    console.log(y); // undefined
    console.log(x); // throw a Exception --> ReferenceError: Cannot access 'x' before initialization
    let x = 100;
    var y = 100;
}
// f();
// 在 ECMAScript 6 之后出现的let/const变量在“声明（和创建）一个标识符”这件事上，与var并没有什么不同，只是 JavaScript 拒绝访问还没有绑定值的let/const标识符而已。
// ECMAScript 6 之前：JavaScript 是允许访问还没有绑定值的var所声明的标识符的。
// 这种标识符后来统一约定称为“变量声明（varDelcs）”，而“let/const”则称为“词法声明（lexicalDecls）”。
// JavaScript 环境在创建一个“变量名（varName in varDecls）”后，会为它初始化绑定一个 undefined 值。
// 而”词法名字（lexicalNames）”在创建之后就没有这项待遇，所以它们在缺省情况下就是“还没有绑定值”的标识符。

// 6 种声明语句中的 *函数* 是按 varDecls 的规则声明的；
// *类* 的内部是处于严格模中，它的名字是按 let 来处理的
// *import* 导入的名字则是按 const 的规则来处理的。
// 所以，所有的声明本质上只有三种处理模式：var 变量声明、let 变量声明和 const 常量声明。


// 在 JavaScript 中赋值操作是 lRef = rValue 
// 也就是将右操作数（的值）赋给左操作数（的引用）
// 也就是说，在 JavaScript 中，一个赋值表达式的左边和右边其实 *“都是”表达式*！

// 从 JavaScript 1.0 开始就遗留下来的一个巨坑，也就是所谓的“变量泄漏”问题。
// 如果你向一个不存在的变量名赋值，那么 JavaScript 会在全局范围内创建它。
// 少量代码中相当易用，但代码规模扩大时，便相当不利于维护
// 从 ECMAScript5 开始的严格模式就禁止了这种特性，试图避免用户将变量泄露到全局环境。

// 在早期设计中，JavaScript 的全局环境是引擎使用一个称为“全局对象”东西管理起来的。
// 这个全局对象几乎类似或完全等同于一个普通对象。
// 只不过，JavaScript 引擎将全局的一些缺省对象、运行期环境的原生对象等东西都初始化在这个全局对象的属性中，并使用这个对象创建了一个称为“全局对象闭包”的东西，从而得到了 JavaScript 的全局环境。

// 为了兼容旧的 JavaScript 语言设计，现在的 JavaScript （ECMAScript 6之后）环境仍然是通过将全局对象初始化为这样的一个全局闭包来实现的。
// 为了得到一个“尽可能”与其它变量环境相似的声明效果（varDecls）
// ECMAScript 规定在这个全局对象之外再维护一个变量名列表（varNames）
// 所有在 静态语法分析期 或 在 eval() 中使用 *var声明* 的变量名就被放在这个列表中。
// 然后约定，这个变量名列表中的变量是“直接声明的变量”，不能使用delete删除（configurable: false）。
var z = 2;
eval('var z2 = 3;');
console.log(globalThis.z, globalThis.z2);       // 2 3
console.log(delete globalThis.z, delete globalThis.z2);    // false true
console.log(globalThis.z, globalThis.z2);       // 2 undefined
// 这里有个特例  通过eval动态 var声明的 *是可以删除* 的

/**
 * 总结： var x = y = 100 发生了什么？
 * 等号的右边是一个表达式y = 100，它发生了一次“向不存在的变量赋值”，隐式地声明了一个全局变量y，并赋值为 100
 * 而一个赋值表达式操作的本身也是有“结果（Result）”的，它是右操作数的值
 * 这行代码表示的是 var 声明了一个x变量 并且在初始化赋值时 执行右手端赋值表达式得到了一个结果 100 ，而执行右手端表达式时又想全局泄露了一个y变量并赋值这个y变量为100
 * 
 * 1. var 等声明语句总是在变量作用域（变量表）或词法作用域中静态地声明一个或多个标识符
 * 2. 全局变量的管理方式决定了“向一个不存在的变量赋值”所导致的变量泄露是不可避免的。
 * 3. 动态添加的“var 声明”是可以删除的，这是唯一能操作 varNames 列表的方式（不过它并不存在多少实用意义）
 * 4. 变量声明在引擎的处理上被分成两个部分：一部分是静态的、基于标识符的词法分析和管理，它总是在相应上下文的环境构建时作为名字创建的；另一部分是表达式执行过程，是对上述名字的赋值，这个过程也称为绑定
 * 5. x 和 y 是两个不同的东西，前者是声明的名字，后者是一个赋值过程可能创建的变量名
 */

